# PermutationsProject
## Introduction  
Едно от фундаменталните понятия в математиката е функция. В дискретната математика и в часност в компютърните науки се нуждаем от разглеждането на понятието функция на теоретико-множествено ниво. Ние използваме функции при дефинирането на дискретни структури като редици и стрингове, при оценяване времевата сложност на дадена програма и съоветно ефективността на даден алгоритъм. Алгоритмите за сортиране например са пряко свързани с биекциите (взаимно-еднозначни съответствия) върху крайно множество елементи - така наречените пермутации. Пермутациите на n-елемента с дефинирана операция композиция (◦) образуват дискретна структура, наречена пермутационна група, която има редица интересни свойства.

![alt text](https://github.com/KingGVT/PermutationsProject/blob/master/PermutationsImage1.PNG?raw=true)  

### Постановка
Изготвянето на проекта предполага реализация на C++ на редица функции, свързани с понятието пермутация.


#### Пермутации
Функция от множеството A в множеството B наричаме съответствие f, което съпоставя на всеки елемент a ∈ A единствен елемент b ∈ B. Елемента b наричаме образ на a и означаваме с f(a), а елемента a наричаме първообраз на b. Функцията означаваме с f : A → B, като множеството A наричаме дефиниционна област.
###### Задача 1. 
Да се дефинира двумерен динамичен масив, който има размерност 2 реда и n стълба, с помощта на който ще представяме функция върху множество с n елемента.
###### Задача 2. 
Да се дефинира функция на С++ за запълване на двумерен масив по зададено от потребителя множество от стойности на функция.
Една функция f : A → B наричаме инективна или инекция, ако тя приема различни стойности в различни точки от дефиниционната си област, т.е. ако x, y ∈ A и x 6= y, то f(x) 6= f(y).
###### Задача 3. 
Да се дефинира функция на С++, която проверява дали записана в масив функция е инекция.
Една функция f : A → B наричаме сюрективна или сюрекция, ако всеки елемент от множеството B има първообраз.
###### Задача 4. 
Да се дефинира функция на С++, която проверява дали записана в масив функция е сюрекция.
Една функция f : A → B наричаме биективна или биекция, ако тя е едновременно инекция и сюрекция. Казваме още, че f е взаимно еднозначно съответствие между A и B. Ако A е крайно множество, то |A| = |B| и f наричаме
пермутация.
###### Задача 5. 
Да се дефинира функция на С++, която проверява дали записана в масив функция е пермутация.
Нека n ∈ N. Ако с Pn означим броя на пермутациите на n-елемента, то Pn = n! = 1.2.3. ...n.
###### Задача 6.
Да се дефинира функция на С++, която намира броя на пермутациите на зададеното от потребителя множество.


#### Неподвижни точки
Ако f : A → B и f(x) = x, за някое x ∈ A, то x наричаме неподвижна точка за функцията f. Ако всяка точка от множеството A е неподвижна, то функцията f наричаме идентитет върху A и означаваме с idA или само с id, ако
множеството A се подразбира.
###### Задача 7.
Да се дефинира функция на С++, която проверява дали записана в масив пермутация има неподвижна точка.
###### Задача 8.
Да се дефинира функция на С++, която намира броя на неподвижните точки на една пермутация.
###### Задача 9. 
Да се дефинира функция на С++, която проверява дали записана в масив пермутация е идентитет.


#### Независими цикли
Съществува компактен начин за представяне на една пермутация σ върху крайно множество S, т. нар. представяне като произведение на независими цикли. Започвайки от някой произволен елемент на S, да речем x, записваме редицата *(x, σ(x), σ(σ(x)), .. .)*
от последователни образи на σ дотогава, докато съответния образ не е равен на x. Затварянето на скобата дава съответния цикъл на σ. След това продължаваме с избор на произволен друг елемент y от S, който не е бил включен в някои от предходните цикли и така формираме нов цикъл включващ y. Тъй като S е крайно множество този процес ще е краен и ни води до образуването на всички цикли на пермутацията. В случай когато дължината на един цикъл е единица (т.е. елемента е неподвижен) е прието за по-добра компактност да се пропуска, като се подразбира. Това представянене е еднозначно с точност до циклично пренареждане на елементите в цикъла и пренареждане на самите цикли. 

![alt text](https://github.com/KingGVT/PermutationsProject/blob/master/PermutationsImage2.PNG?raw=true)

###### Задача 10. 
Да се дефинира функция на С++, която представя дадена пермутация във вид на независими цикли и ги отпечатва на екрана. 
###### Задача 11. 
Да се дефинира функция на С++, която намира дължините на независимите цикли, чрез които се представя пермутацията, като тези дължини се запишат в едномерен динамичен масив. 
###### Задача 12. 
Да се дефинира функция на С++, която получава като аргумент пермутация, представена като произведение от независими цикли и я отпечатва в табличен вид в конзолата.


#### Композиция 

![alt text](https://raw.githubusercontent.com/KingGVT/PermutationsProject/master/PermutationsImage3.PNG?token=AYwFVcNp7OOMa5FLH1obN9LcDyGx9eoEks5cYvsiwA%3D%3D)

###### Задача 13. 
Да се дефинира функция на С++, която намира композицията на две пермутации и отпечатва получената пермутация в табличен вид в конзолата.


#### Обратна пермутация

![alt text](https://raw.githubusercontent.com/KingGVT/PermutationsProject/master/PermutationsImage4.PNG?token=AYwFVbcpr0PdqoTLAqqaevNj-VUg0Qdfks5cYvtrwA%3D%3D)

Пермутацията g наричаме обратна пермутация на f и я означаваме с f−1. Представянето на една пермутация като произведение от независими цикли позволява бързо пресмятане на обратните пермутации, посредством обръщане реда на всеки независим цикъл.

![alt text](https://raw.githubusercontent.com/KingGVT/PermutationsProject/master/PermutationsImage5.PNG?token=AYwFVQ04FYXLW122CPr-zJi2MwKPO8F9ks5cYvuXwA%3D%3D)

###### Задача 14. 
Да се дефинира функция на С++, която намира обратната пермутация на дадена пермутация. 
###### Задача 15. 
Да се дефинира функция на С++, която намира композицията на пермутация с нейната обратна и проверява дали полученият резултат е идентитет. 
###### Задача 16. 
Да се дефинира функция на С++, която проверява, че ако две пермутации са различни от идентитет, т.е. f != id и g != id, то операцията композиция е некомутативна, т.е. f ◦ g != g ◦ f.


#### Итерация 

![alt text](https://raw.githubusercontent.com/KingGVT/PermutationsProject/master/PermutationsImage6.PNG?token=AYwFVW3yFepS4gUMLlssmkMk0sEiq1rYks5cYvwCwA%3D%3D)

От всяка пермутация можем да получим идентитет след определен брой итерации, т.е. fk = id, за накое k ∈ N0. Минималният брой итерации е равен на най-малкото общо кратно (НОК) на дължините на независимите цикли.
###### Пример. 
Нека σ1 = (1 2 3)(4 5), σ2 = (1 5 4 6)(2 3). Понеже НОК(3,2,1) = 6 и НОК(4,2) = 4, то σ^6 1 = id, σ^4 2 = id.

###### Задача 17. 
Да се дефинира функция на С++, която намира минималното k, за което fk = id, посредством
(а) последователнa проверка, дали f^1 = id, f^2 = id и т.н;
(б) намиране НОК от дължините на независимите цикли на пермутацията и проверка, че след съответния брой итерации резултатът е идентитет.
В допълнение, сравнете ефктивността по отношение на време при двата подхода.



